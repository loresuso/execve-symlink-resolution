# execve-symlink-resolution

## Basic idea

BPF subsystem offers the possibility to resolve path using `bpf_d_path`. This function cannot be invoked from every possible hook point, but only on a restricted set of them. Here is how the whitelist is defined: https://github.com/torvalds/linux/blob/master/kernel/trace/bpf_trace.c#L920

As you can see, `security_file_open` is in there.
By better observing how security modules uses this hook, we can notice that the the `task_struct` has an `in_execve` field that serves the purpose to communicate to LSMs if the current process is executing something. AppArmor example: https://elixir.bootlin.com/linux/latest/source/security/apparmor/lsm.c#L456

Comment on `task_struct`:
> /* Bit to tell LSMs we're in execve(): */

So the idea is to hook into `security_file_open` and check whether we are in `execve`. If so, we temporarily store the resolved path in a map for later retrieval on `execve` exit or `sched_process_exec`. From there, we can then push to userspace the resolved path as we want.

## Major advantages of this solution
- not writing custom code for path resolution, it would be really error prone
- solve symlinks on execve
- solve memfd fileless execution

## Kernel versions supported 
todo
